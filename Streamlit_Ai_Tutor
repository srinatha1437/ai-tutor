import streamlit as st
import json
import re

try:
    import openai
    OPENAI_AVAILABLE = True
except Exception:
    OPENAI_AVAILABLE = False


# === SOCATIC LOGIC ===
def simple_fallback_questions(topic: str, student_text: str):
    """Offline fallback Socratic questioning."""
    sentences = [s.strip() for s in re.split(r'[\.\n]', student_text) if s.strip()]
    claims = sentences[:3] if sentences else [student_text]

    interventions, questions = [], []
    for i, c in enumerate(claims):
        if re.search(r"always|never|must|everyone|nobody|impossible", c, re.IGNORECASE):
            interventions.append({"index": i, "type": "sweeping_generalization", "text": c})
            questions.append(f"You said '{c}'. Could there be exceptions?")
        elif re.search(r"because|since|due to|as a result", c, re.IGNORECASE):
            interventions.append({"index": i, "type": "causal_assumption", "text": c})
            questions.append(f"What evidence supports the causal link in '{c}'?")
        else:
            interventions.append({"index": i, "type": "unstated_assumption", "text": c})
            questions.append(f"What assumptions underlie '{c}'?")

    return {
        "initial_claims": claims,
        "interventions": interventions,
        "questions": questions,
        "final_suggestions": [
            "Avoid overgeneralizations.",
            "Clarify assumptions.",
            "Support claims with evidence."
        ],
    }


def call_openai_generate(topic: str, student_text: str, dialog_history, api_key: str):
    """Call OpenAI (or fallback if unavailable)."""
    if not OPENAI_AVAILABLE or not api_key:
        return simple_fallback_questions(topic, student_text)

    openai.api_key = api_key
    system_prompt = (
        "You are a Socratic Dialogue Tutor. Never give direct answers. "
        "Respond with JSON containing: initial_claims, interventions, questions, final_suggestions."
    )
    user_prompt = f"Topic: {topic}\nStudent submission:\n{student_text}"

    try:
        resp = openai.ChatCompletion.create(
            model="gpt-4o-mini",
            messages=[
                {"role": "system", "content": system_prompt},
                {"role": "user", "content": user_prompt},
            ],
            max_tokens=600,
            temperature=0.8,
        )
        content = resp.choices[0].message.content
        json_text = content[content.find("{"): content.rfind("}") + 1]
        return json.loads(json_text)
    except Exception as e:
        print(f"LLM call failed: {e}")
        return simple_fallback_questions(topic, student_text)


# === STREAMLIT APP ===
st.set_page_config(page_title="Socratic Dialogue Tutor", layout="centered")

st.markdown("""
<style>
.stApp { background: linear-gradient(135deg, #0f172a 0%, #071024 50%); color: #e6eef8; font-family: 'Inter', sans-serif; }
.card { background: rgba(255,255,255,0.03); padding:16px; border-radius:12px; box-shadow: 0 6px 18px rgba(2,6,23,0.6); }
</style>
""", unsafe_allow_html=True)

st.title("üí¨ Socratic Dialogue Tutor")
st.caption("AI that teaches by questioning ‚Äî not telling.")

if 'dialogue' not in st.session_state:
    st.session_state.dialogue = []
if 'trace' not in st.session_state:
    st.session_state.trace = []

with st.sidebar:
    st.header("Settings")
    topic = st.selectbox("Choose a topic:", [
        "What is justice?", "What makes an action moral?",
        "Does free will exist?", "What is legal responsibility?", "Custom..."
    ])
    if topic == "Custom...":
        topic = st.text_input("Enter custom topic:", "What is knowledge?")
    api_key = st.text_input("OpenAI API Key (optional)", type="password")

st.markdown("<div class='card'>", unsafe_allow_html=True)
student_input = st.text_area("‚úçÔ∏è Write your argument or claim:", height=150)

col1, col2 = st.columns(2)
with col1:
    if st.button("üîÅ Reset Dialogue"):
        st.session_state.dialogue, st.session_state.trace = [], []
        st.rerun()
with col2:
    if st.button("ü§î Analyze & Ask"):
        if not student_input.strip():
            st.warning("Please enter a statement first.")
        else:
            parsed = call_openai_generate(topic, student_input, st.session_state.dialogue, api_key)
            st.session_state.dialogue.append({"role": "student", "text": student_input})
            st.session_state.dialogue.append({"role": "tutor", "text": json.dumps(parsed)})
            for it in parsed.get("interventions", []):
                st.session_state.trace.append(it)
            st.rerun()
st.markdown("</div>", unsafe_allow_html=True)

if st.session_state.dialogue:
    st.subheader("üó£ Dialogue")
    for turn in st.session_state.dialogue:
        if turn["role"] == "student":
            st.markdown(f"**Student:** {turn['text']}")
        elif turn["role"] == "tutor":
            try:
                parsed = json.loads(turn["text"])
                for i, q in enumerate(parsed.get("questions", []), 1):
                    st.markdown(f"**Tutor Q{i}:** {q}")
            except Exception:
                st.write(turn["text"])

st.markdown("---")
response = st.text_area("üí≠ Respond or refine your argument:", height=120)
if st.button("Submit Response"):
    if not response.strip():
        st.warning("Enter your response.")
    else:
        parsed2 = call_openai_generate(topic, response, st.session_state.dialogue, api_key)
        st.session_state.dialogue.append({"role": "student", "text": response})
        st.session_state.dialogue.append({"role": "tutor", "text": json.dumps(parsed2)})
        for it in parsed2.get("interventions", []):
            st.session_state.trace.append(it)
        st.rerun()

if st.session_state.trace:
    st.subheader("üß© Reasoning Trace")
    for idx, it in enumerate(st.session_state.trace, 1):
        st.write(f"{idx}. [{it['type']}] {it['text']}")
    st.markdown("---")
    st.subheader("üìò Feedback Summary")
    types = {}
    for it in st.session_state.trace:
        types[it["type"]] = types.get(it["type"], 0) + 1
    for typ, count in types.items():
        st.write(f"- {typ}: {count} time(s)")
st.caption("Built with a Socratic-first approach ‚Äî guiding discovery through questioning.")
